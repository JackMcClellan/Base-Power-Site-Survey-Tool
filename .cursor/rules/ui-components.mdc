
# Web Application - Development Rules

## Project Overview
Next.js web application with TypeScript, ShadCN UI components, and Tailwind CSS. Uses modern web development patterns with server-side rendering, client components, and responsive design.

## Core Patterns & Conventions

### 1. Project Structure & Organization
- **app/** - Next.js App Router pages and layouts
- **components/** - Reusable React components
- **components/ui/** - ShadCN UI primitive components
- **lib/** - Utility functions and configurations
- **public/** - Static assets
- **types/** or **@types/** - TypeScript type definitions

### 2. Component Architecture & Folder Structure
- **components/ui/** - Contains primitive, low-level UI components from ShadCN
  - These are generated/installed ShadCN components with minimal customization
  - Examples: Button, Card, Dialog, Input, Select, Badge
  - Should NOT be heavily modified - use composition instead
  - Must follow ShadCN conventions and use Tailwind classes
- **components/** - Contains composed, application-specific components
  - These components are built using `components/ui/` components
  - Examples: Header, Navigation, DataTable, Forms
  - Can import from both `components/ui/` and other utilities
  - Should compose multiple UI components to create complex functionality

### 3. ShadCN UI Usage
- **ALWAYS** use ShadCN UI components from `@/components/ui` before creating custom components
- **AVAILABLE** core ShadCN components to check first:
  - `Button` - Various button variants (default, destructive, outline, secondary, ghost, link)
  - `Card` - Container components (Card, CardHeader, CardContent, CardFooter)
  - `Dialog` - Modal dialogs with overlay
  - `Input` - Form input fields
  - `Select` - Dropdown selection components
  - `Badge` - Status indicators and labels
  - `Separator` - Visual dividers
  - `ScrollArea` - Scrollable containers
  - `Sheet` - Slide-out panels
  - `Tabs` - Tabbed interfaces
  - `Form` - Form components with React Hook Form integration
- **INSTALLATION**: Use `npx shadcn@latest add <component>` to add new ShadCN components
- **CUSTOMIZATION**: Modify ShadCN components through Tailwind classes and CSS variables, not by editing the component files directly

### 4. Styling & Theming
- **ALWAYS** use Tailwind CSS classes for styling
- **ALWAYS** use CSS variables defined in `globals.css` for theme colors
- **NEVER** use inline styles or styled-components
- **PREFER** Tailwind utility classes over custom CSS
- **PATTERN** for responsive design:
```tsx
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4">
  {/* Responsive grid layout */}
</div>
```
- **PATTERN** for theme-aware styling:
```tsx
<div className="bg-background text-foreground border border-border rounded-lg p-4">
  {/* Uses CSS variables for theming */}
</div>
```

### 5. Component Creation Guidelines
- **ALWAYS** check existing ShadCN components before creating new ones
- **IF** ShadCN component exists, use composition to build complex components
- **IF** creating new UI components, follow ShadCN patterns and conventions
- **ALWAYS** use TypeScript with proper prop interfaces
- **PATTERN** for component structure:
```tsx
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"

interface ComponentProps {
  title: string
  children: React.ReactNode
  className?: string
}

export function Component({ title, children, className }: ComponentProps) {
  return (
    <Card className={cn("w-full", className)}>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent>
        {children}
      </CardContent>
    </Card>
  )
}
```

### 6. Form Development Patterns
- **ALWAYS** use React Hook Form for form state management and validation
- **ALWAYS** use ShadCN Form components for consistent form layouts
- **ALWAYS** use Zod for form validation schemas
- **PATTERN** for form development:
```tsx
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"
import { Button } from "@/components/ui/button"
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form"
import { Input } from "@/components/ui/input"

const formSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
})

type FormData = z.infer<typeof formSchema>

export function MyForm() {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: "",
      email: "",
    },
  })

  const onSubmit = async (data: FormData) => {
    try {
      // Handle form submission
      console.log(data)
    } catch (error) {
      console.error("Form submission error:", error)
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="Enter your name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" placeholder="Enter your email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? "Submitting..." : "Submit"}
        </Button>
      </form>
    </Form>
  )
}
```

### 7. Navigation & Routing
- **ALWAYS** use Next.js App Router for navigation
- **ALWAYS** use `next/link` for client-side navigation
- **ALWAYS** use `next/navigation` hooks for programmatic navigation
- **PATTERN** for navigation:
```tsx
import Link from "next/link"
import { useRouter, usePathname } from "next/navigation"
import { Button } from "@/components/ui/button"

export function Navigation() {
  const router = useRouter()
  const pathname = usePathname()

  return (
    <nav className="flex space-x-4">
      <Link href="/">
        <Button variant={pathname === "/" ? "default" : "ghost"}>
          Home
        </Button>
      </Link>
      <Link href="/about">
        <Button variant={pathname === "/about" ? "default" : "ghost"}>
          About
        </Button>
      </Link>
      <Button onClick={() => router.push("/dashboard")}>
        Go to Dashboard
      </Button>
    </nav>
  )
}
```

### 8. State Management
- **PREFER** React built-in state (useState, useContext) for simple state
- **USE** Zustand or Redux Toolkit for complex global state
- **PATTERN** for local state:
```tsx
import { useState, useEffect } from "react"

export function Component() {
  const [data, setData] = useState<DataType[]>([])
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true)
      try {
        const response = await fetch("/api/data")
        const result = await response.json()
        setData(result)
      } catch (error) {
        console.error("Failed to fetch data:", error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [])

  // Component logic
}
```

### 9. Error Handling & Loading States
- **ALWAYS** implement proper error boundaries
- **ALWAYS** show loading states for async operations
- **ALWAYS** provide user feedback for actions
- **PATTERN** for error handling:
```tsx
import { useState } from "react"
import { Button } from "@/components/ui/button"
import { useToast } from "@/hooks/use-toast"

export function ActionComponent() {
  const [loading, setLoading] = useState(false)
  const { toast } = useToast()

  const handleAction = async () => {
    setLoading(true)
    try {
      await performAction()
      toast({
        title: "Success",
        description: "Action completed successfully",
      })
    } catch (error) {
      toast({
        title: "Error",
        description: "Something went wrong",
        variant: "destructive",
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Button onClick={handleAction} disabled={loading}>
      {loading ? "Loading..." : "Perform Action"}
    </Button>
  )
}
```

### 10. TypeScript Patterns
- **ALWAYS** use proper TypeScript types and interfaces
- **ALWAYS** define component prop interfaces
- **PREFER** type inference over explicit typing where clear
- **PATTERN** for component props:
```tsx
interface ComponentProps {
  title: string
  description?: string
  items: Array<{
    id: string
    name: string
    value: number
  }>
  onItemClick?: (id: string) => void
  className?: string
}

export function Component({ 
  title, 
  description, 
  items, 
  onItemClick, 
  className 
}: ComponentProps) {
  // Component implementation
}
```

### 11. Data Fetching
- **PREFER** Next.js built-in data fetching (Server Components, fetch with cache)
- **USE** SWR or TanStack Query for client-side data fetching
- **PATTERN** for server-side data fetching:
```tsx
// Server Component
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // Cache for 1 hour
  })
  
  if (!res.ok) {
    throw new Error('Failed to fetch data')
  }
 
  return res.json()
}

export default async function Page() {
  const data = await getData()
 
  return (
    <div>
      {/* Render data */}
    </div>
  )
}
```

### 12. Accessibility
- **ALWAYS** include proper ARIA labels and roles
- **ALWAYS** ensure keyboard navigation works
- **ALWAYS** provide alt text for images
- **ALWAYS** use semantic HTML elements
- **PATTERN** for accessible components:
```tsx
import { Button } from "@/components/ui/button"

export function AccessibleComponent() {
  return (
    <div role="main" aria-labelledby="main-heading">
      <h1 id="main-heading">Page Title</h1>
      <Button 
        aria-label="Save document"
        onClick={handleSave}
      >
        Save
      </Button>
    </div>
  )
}
```

### 13. Performance Optimization
- **ALWAYS** use React.memo for expensive components
- **ALWAYS** use useCallback and useMemo appropriately
- **PREFER** Server Components when possible
- **USE** dynamic imports for code splitting
- **PATTERN** for performance optimization:
```tsx
import { memo, useCallback, useMemo } from "react"
import dynamic from "next/dynamic"

// Dynamic import for heavy components
const HeavyComponent = dynamic(() => import("./HeavyComponent"), {
  loading: () => <div>Loading...</div>
})

export const OptimizedComponent = memo(function OptimizedComponent({ 
  data, 
  onUpdate 
}: Props) {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: true
    }))
  }, [data])

  const handleUpdate = useCallback((id: string) => {
    onUpdate(id)
  }, [onUpdate])

  return (
    <div>
      {/* Component content */}
    </div>
  )
})
```

## Code Quality Standards

### Imports Organization
```tsx
// 1. React and Next.js imports
import React from "react"
import Link from "next/link"
import { useRouter } from "next/navigation"

// 2. Third-party libraries
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import * as z from "zod"

// 3. Internal utilities and configs
import { cn } from "@/lib/utils"
import { api } from "@/lib/api"

// 4. UI components
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader } from "@/components/ui/card"

// 5. Internal components
import { Header } from "@/components/header"
import { Footer } from "@/components/footer"

// 6. Types
import type { User } from "@/types/user"
```

### File Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Pages**: kebab-case (e.g., `user-profile/page.tsx`)
- **Utilities**: camelCase (e.g., `formatDate.ts`)
- **Types**: PascalCase (e.g., `UserTypes.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)

## ShadCN UI Component Inventory
Before creating new components, check these existing ShadCN components:

### Layout & Structure
- **Card** - Container with header, content, and footer sections
- **Separator** - Visual dividers between content sections
- **ScrollArea** - Scrollable content containers
- **Sheet** - Slide-out panels and drawers

### Forms & Inputs
- **Form** - React Hook Form integration with validation
- **Input** - Text input fields with variants
- **Textarea** - Multi-line text input
- **Select** - Dropdown selection with search
- **Checkbox** - Boolean input with label
- **RadioGroup** - Single selection from multiple options
- **Switch** - Toggle switch input
- **Slider** - Range input slider

### Feedback & Status
- **Button** - Action buttons with multiple variants
- **Badge** - Status indicators and labels
- **Progress** - Progress bars and indicators
- **Skeleton** - Loading placeholders
- **Spinner** - Loading indicators
- **Toast** - Notification messages
- **Alert** - Alert messages with variants

### Navigation & Interaction
- **Tabs** - Tabbed content interfaces
- **Dialog** - Modal dialogs and overlays
- **Popover** - Floating content containers
- **Tooltip** - Hover information displays
- **DropdownMenu** - Context menus and actions
- **NavigationMenu** - Main site navigation

### Data Display
- **Table** - Structured data display
- **Avatar** - User profile images with fallbacks
- **Calendar** - Date selection and display
- **Command** - Command palette and search

## Do Not:
- Modify ShadCN UI components directly - use composition instead
- Use inline styles or styled-components
- Create custom components without checking ShadCN inventory first
- Ignore accessibility requirements
- Skip TypeScript typing for component props
- Use hardcoded colors instead of CSS variables
- Forget to handle loading and error states

## Always:
- Use ShadCN UI components as building blocks
- Follow Tailwind CSS conventions for styling
- Implement proper TypeScript interfaces
- Include accessibility attributes
- Handle error states and loading states
- Use semantic HTML elements
- Optimize for performance with React best practices
- Follow Next.js conventions for routing and data fetching
- Use proper state management patterns

- Maintain consistent component structure
- Include proper error handling and user feedback
- Export new UI components from `@/components/ui/index.ts`
- **ALWAYS** update this rules file when creating new components
